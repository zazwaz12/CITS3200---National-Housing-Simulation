"""
This type stub file was generated by pyright.
"""

"""
This module contains the base classes for pathos pool and pipe objects,
and describes the map and pipe interfaces.  A pipe is defined as a
connection between two 'nodes', where a node is something that does
work.  A pipe may be a one-way or two-way connection.  A map is defined
as a one-to-many connection between nodes.  In both map and pipe
connections, results from the connected nodes can be returned to the
calling node.  There are several variants of pipe and map, such as
whether the connection is blocking, or ordered, or asynchronous.  For
pipes, derived methods must overwrite the 'pipe' method, while maps
must overwrite the 'map' method.  Pipes and maps are available from
worker pool objects, where the work is done by any of the workers
in the pool.  For more specific point-to-point connections (such as
a pipe between two specific compute nodes), use the pipe object
directly.


Usage
=====

A typical call to a pathos map will roughly follow this example:

    >>> # instantiate and configure the worker pool
    >>> from pathos.pools import ProcessPool
    >>> pool = ProcessPool(nodes=4)
    >>>
    >>> # do a blocking map on the chosen function
    >>> results = pool.map(pow, [1,2,3,4], [5,6,7,8])
    >>>
    >>> # do a non-blocking map, then extract the results from the iterator
    >>> results = pool.imap(pow, [1,2,3,4], [5,6,7,8])
    >>> print("...")
    >>> results = list(results)
    >>>
    >>> # do an asynchronous map, then get the results
    >>> results = pool.amap(pow, [1,2,3,4], [5,6,7,8])
    >>> while not results.ready():
    ...     time.sleep(5); print(".", end=' ')
    ...
    >>> results = results.get()


Notes
=====

Each of the pathos worker pools rely on a different transport protocol
(e.g. threads, multiprocessing, etc), where the use of each pool comes
with a few caveats.  See the usage documentation and examples for each
worker pool for more information.

"""
__all__ = ["AbstractPipeConnection", "AbstractWorkerPool"]

class AbstractPipeConnection:
    """
    AbstractPipeConnection base class for pathos pipes.
    """

    def __init__(self, *args, **kwds) -> None:
        """
        Required input:
            ???

        Additional inputs:
            ???

        Important class members:
            ???

        Other class members:
            ???
        """
        ...

    def __repr__(self):  # -> str:
        ...

class AbstractWorkerPool:
    """
    AbstractWorkerPool base class for pathos pools.
    """

    __nodes = ...
    def __init__(self, *args, **kwds) -> None:
        """
        Important class members:
            nodes	- number (and potentially description) of workers
            ncpus       - number of worker processors
            servers     - list of worker servers
            scheduler   - the associated scheduler
            workdir     - associated $WORKDIR for scratch calculations/files

        Other class members:
            scatter     - True, if uses 'scatter-gather' (instead of 'worker-pool')
            source      - False, if minimal use of TemporaryFiles is desired
            timeout	- number of seconds to wait for return value from scheduler
        """
        ...

    def __enter__(self):  # -> Self:
        ...

    def __exit__(self, *args):  # -> None:
        ...

    def clear(self):
        """Remove server with matching state"""
        ...

    def map(self, f, *args, **kwds):
        """run a batch of jobs with a blocking and ordered map

        Returns a list of results of applying the function f to the items of
        the argument sequence(s). If more than one sequence is given, the
        function is called with an argument list consisting of the corresponding
        item of each sequence. Some maps accept the `chunksize` keyword, which
        causes the sequence to be split into tasks of approximately the given size.
        """
        ...

    def imap(self, f, *args, **kwds):
        """run a batch of jobs with a non-blocking and ordered map

        Returns a list iterator of results of applying the function f to the items
        of the argument sequence(s). If more than one sequence is given, the
        function is called with an argument list consisting of the corresponding
        item of each sequence. Some maps accept the `chunksize` keyword, which
        causes the sequence to be split into tasks of approximately the given size.
        """
        ...

    def uimap(self, f, *args, **kwds):
        """run a batch of jobs with a non-blocking and unordered map

        Returns a list iterator of results of applying the function f to the items
        of the argument sequence(s). If more than one sequence is given, the
        function is called with an argument list consisting of the corresponding
        item of each sequence. The order of the resulting sequence is not guaranteed.
        Some maps accept the `chunksize` keyword, which causes the sequence to be
        split into tasks of approximately the given size.
        """
        ...

    def amap(self, f, *args, **kwds):
        """run a batch of jobs with an asynchronous map

        Returns a results object which containts the results of applying the
        function f to the items of the argument sequence(s). If more than one
        sequence is given, the function is called with an argument list consisting
        of the corresponding item of each sequence. To retrieve the results, call
        the get() method on the returned results object. The call to get() is
        blocking, until all results are retrieved. Use the ready() method on the
        result object to check if all results are ready. Some maps accept the
        `chunksize` keyword, which causes the sequence to be split into tasks of
        approximately the given size.
        """
        ...

    def pipe(self, f, *args, **kwds):
        """submit a job and block until results are available

        Returns result of calling the function f on a selected worker.  This function
        will block until results are available.
        """
        ...

    def apipe(self, f, *args, **kwds):
        """submit a job asynchronously to a queue

        Returns a results object which containts the result of calling the
        function f on a selected worker. To retrieve the results, call the
        get() method on the returned results object. The call to get() is
        blocking, until the result is available. Use the ready() method on the
        results object to check if the result is ready.
        """
        ...

    def __repr__(self):  # -> str:
        ...
