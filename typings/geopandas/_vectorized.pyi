"""
This type stub file was generated by pyright.
"""

import numpy as np

from . import _compat as compat

"""
This type stub file was generated by pyright.
"""
_names = ...
if compat.USE_SHAPELY_20 or compat.USE_PYGEOS:
    geometry_type_ids = ...
    geometry_type_values = np.array(list(type_mapping.values()), dtype=object)
else:
    ...

def isna(value):
    """
    Check if scalar value is NA-like (None, np.nan or pd.NA).

    Custom version that only works for scalars (returning True or False),
    as `pd.isna` also works for array-like input returning a boolean array.
    """
    ...

def from_shapely(data):
    """
    Convert a list or array of shapely objects to an object-dtype numpy
    array of validated geometry elements.

    """
    ...

def to_shapely(data): ...
def from_wkb(data):
    """
    Convert a list or array of WKB objects to a np.ndarray[geoms].
    """
    ...

def to_wkb(data, hex=..., **kwargs): ...
def from_wkt(data):
    """
    Convert a list or array of WKT objects to a np.ndarray[geoms].
    """
    ...

def to_wkt(data, **kwargs): ...
def points_from_xy(x, y, z=...): ...
def is_valid(data): ...
def is_empty(data): ...
def is_simple(data): ...
def is_ring(data): ...
def is_closed(data): ...
def has_z(data): ...
def geom_type(data): ...
def area(data): ...
def length(data): ...
def boundary(data): ...
def centroid(data): ...
def concave_hull(data, **kwargs): ...
def convex_hull(data): ...
def delaunay_triangles(data, tolerance, only_edges): ...
def envelope(data): ...
def minimum_rotated_rectangle(data): ...
def exterior(data): ...
def extract_unique_points(data): ...
def offset_curve(data, distance, quad_segs=..., join_style=..., mitre_limit=...): ...
def interiors(data): ...
def remove_repeated_points(data, tolerance=...): ...
def representative_point(data): ...
def minimum_bounding_circle(data): ...
def minimum_bounding_radius(data): ...
def segmentize(data, max_segment_length): ...
def covers(data, other): ...
def covered_by(data, other): ...
def contains(data, other): ...
def crosses(data, other): ...
def disjoint(data, other): ...
def equals(data, other): ...
def intersects(data, other): ...
def overlaps(data, other): ...
def touches(data, other): ...
def within(data, other): ...
def equals_exact(data, other, tolerance): ...
def clip_by_rect(data, xmin, ymin, xmax, ymax): ...
def difference(data, other): ...
def intersection(data, other): ...
def symmetric_difference(data, other): ...
def union(data, other): ...
def shortest_line(data, other): ...
def distance(data, other): ...
def hausdorff_distance(data, other, densify=..., **kwargs): ...
def frechet_distance(data, other, densify=..., **kwargs): ...
def buffer(data, distance, resolution=..., **kwargs): ...
def interpolate(data, distance, normalized=...): ...
def simplify(data, tolerance, preserve_topology=...): ...
def normalize(data): ...
def make_valid(data): ...
def reverse(data): ...
def project(data, other, normalized=...): ...
def relate(data, other): ...
def unary_union(data): ...
def get_x(data): ...
def get_y(data): ...
def get_z(data): ...
def bounds(data): ...
def transform(data, func): ...
